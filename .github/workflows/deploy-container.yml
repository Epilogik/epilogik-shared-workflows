name: Deploy Container to Server

on:
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment (staging/production/development)'
        required: true
        type: string
      docker_image:
        description: 'Docker image to deploy (e.g., ghcr.io/owner/repo:tag)'
        required: true
        type: string
      container_name:
        description: 'Container name to use'
        required: true
        type: string
      container_port:
        description: 'Internal container port'
        required: true
        type: string
      host_port:
        description: 'Host port to map to'
        required: true
        type: string
      docker_network:
        description: 'Docker network name'
        required: false
        type: string
        default: 'epilogik-net'
      wait_for_health:
        description: 'Wait for container to be healthy'
        required: false
        type: boolean
        default: true
      cleanup_images:
        description: 'Cleanup old Docker images after deployment'
        required: false
        type: boolean
        default: true
      health_check_url:
        description: 'URL to check for application health (optional)'
        required: false
        type: string
        default: ''
      health_check_timeout:
        description: 'Health check timeout in seconds'
        required: false
        type: number
        default: 300
      env_vars:
        description: 'Environment variables for container (JSON format)'
        required: false
        type: string
        default: '{}'
      volumes:
        description: 'Volume mounts for container (JSON array format)'
        required: false
        type: string
        default: '[]'
      restart_policy:
        description: 'Container restart policy'
        required: false
        type: string
        default: 'unless-stopped'
      deploy_strategy:
        description: 'Deployment strategy (rolling/blue-green/recreate)'
        required: false
        type: string
        default: 'rolling'
      rollback_on_failure:
        description: 'Rollback to previous version on deployment failure'
        required: false
        type: boolean
        default: true
    secrets:
      ssh_host:
        description: 'SSH hostname or IP address'
        required: true
      ssh_user:
        description: 'SSH username'
        required: true
      ssh_key:
        description: 'SSH private key'
        required: true
      ssh_port:
        description: 'SSH port number'
        required: false
    outputs:
      deployment_status:
        description: 'Deployment status (success/failed/rolled-back)'
        value: ${{ jobs.deploy.outputs.status }}
      container_id:
        description: 'Deployed container ID'
        value: ${{ jobs.deploy.outputs.container_id }}
      previous_image:
        description: 'Previous container image (for rollback)'
        value: ${{ jobs.deploy.outputs.previous_image }}
      deployment_time:
        description: 'Deployment duration in seconds'
        value: ${{ jobs.deploy.outputs.deployment_time }}

permissions:
  contents: read
  packages: read

jobs:
  deploy:
    name: üöÄ Deploy Container
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: ${{ inputs.environment }}
    outputs:
      status: ${{ steps.deployment.outputs.status }}
      container_id: ${{ steps.deployment.outputs.container_id }}
      previous_image: ${{ steps.deployment.outputs.previous_image }}
      deployment_time: ${{ steps.deployment.outputs.deployment_time }}
    
    steps:
      - name: ‚úÖ Validate deployment inputs
        run: |
          echo "üîç Validating deployment inputs..."
          
          # Validate required secrets
          if [ -z "${{ secrets.ssh_host }}" ]; then
            echo "‚ùå Error: ssh_host secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.ssh_user }}" ]; then
            echo "‚ùå Error: ssh_user secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.ssh_key }}" ]; then
            echo "‚ùå Error: ssh_key secret is not set"
            exit 1
          fi
          
          # Validate environment
          case "${{ inputs.environment }}" in
            staging|production|development)
              echo "‚úÖ Valid environment: ${{ inputs.environment }}"
              ;;
            *)
              echo "‚ùå Error: Invalid environment '${{ inputs.environment }}'. Must be staging, production, or development"
              exit 1
              ;;
          esac
          
          # Validate deployment strategy
          case "${{ inputs.deploy_strategy }}" in
            rolling|blue-green|recreate)
              echo "‚úÖ Valid deployment strategy: ${{ inputs.deploy_strategy }}"
              ;;
            *)
              echo "‚ùå Error: Invalid deployment strategy '${{ inputs.deploy_strategy }}'. Must be rolling, blue-green, or recreate"
              exit 1
              ;;
          esac
          
          echo "‚úÖ All validations passed"
          echo "üéØ Target: ${{ secrets.ssh_user }}@${{ secrets.ssh_host }}"
          echo "üê≥ Image: ${{ inputs.docker_image }}"
          echo "üì¶ Container: ${{ inputs.container_name }}"
          echo "üåç Environment: ${{ inputs.environment }}"
          echo "üöÄ Strategy: ${{ inputs.deploy_strategy }}"

      - name: üîß Setup SSH connection
        run: |
          echo "üîß Setting up SSH connection..."
          
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Setup private key
          echo "${{ secrets.ssh_key }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Add host to known_hosts
          ssh-keyscan -H -p ${{ secrets.ssh_port || '22' }} ${{ secrets.ssh_host }} >> ~/.ssh/known_hosts
          
          # Test SSH connection
          SSH_PORT="${{ secrets.ssh_port || '22' }}"
          if ssh -p $SSH_PORT -o ConnectTimeout=10 -o BatchMode=yes ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} 'echo "SSH connection successful"'; then
            echo "‚úÖ SSH connection established successfully"
          else
            echo "‚ùå Failed to establish SSH connection"
            exit 1
          fi

      - name: üîç Pre-deployment checks
        id: pre-checks
        run: |
          echo "üîç Running pre-deployment checks..."
          
          SSH_PORT="${{ secrets.ssh_port || '22' }}"
          
          # Run pre-checks remotely and capture stdout into PRECHECKS_OUT
          # Run remote prechecks and save stdout to a temp file, then read it
          ssh -p $SSH_PORT ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} 'bash -s' <<'REMOTE_PRECHECKS' > /tmp/epilogik_prechecks.out
            set -euo pipefail

            echo "üê≥ Checking Docker installation..."
            if ! command -v docker &> /dev/null; then
              echo "‚ùå Docker is not installed on the target server"
              exit 1
            fi

            echo "‚úÖ Docker version: $(docker --version)"

            echo "üîç Checking current container status..."
            if docker ps -a --format "table {{.Names}}" | grep -q "^${{ inputs.container_name }}$"; then
              CURRENT_IMAGE=$(docker inspect --format='{{.Config.Image}}' ${{ inputs.container_name }} 2>/dev/null || echo "none")
              echo "CURRENT_IMAGE=$CURRENT_IMAGE"
              echo "üì¶ Current container image: $CURRENT_IMAGE"
            else
              echo "CURRENT_IMAGE=none"
              echo "‚ÑπÔ∏è No existing container found"
            fi

            echo "üíæ Checking available disk space..."
            DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 90 ]; then
              echo "‚ö†Ô∏è Warning: Disk usage is ${DISK_USAGE}% - cleanup may be needed"
            fi

            echo "üîß Checking required ports..."
            if netstat -tlnp | grep -q ":${{ inputs.host_port }} "; then
              PROCESS=$(netstat -tlnp | grep ":${{ inputs.host_port }} " | awk '{print $7}')
              echo "‚ö†Ô∏è Port ${{ inputs.host_port }} is already in use by: $PROCESS"
            else
              echo "‚úÖ Port ${{ inputs.host_port }} is available"
            fi
          REMOTE_PRECHECKS
          PRECHECKS_OUT=$(cat /tmp/epilogik_prechecks.out 2>/dev/null || true)
          echo "$PRECHECKS_OUT"
          # Extract CURRENT_IMAGE marker if present
          CURRENT_IMAGE_VAL=$(echo "$PRECHECKS_OUT" | grep '^CURRENT_IMAGE=' | cut -d'=' -f2- | tr -d '\r' || true)
          if [ -n "$CURRENT_IMAGE_VAL" ]; then
            echo "current_image=$CURRENT_IMAGE_VAL" >> "$GITHUB_OUTPUT"
          else
            echo "current_image=none" >> "$GITHUB_OUTPUT"
          fi

      - name: üöÄ Deploy container
        id: deployment
        run: |
          echo "üöÄ Starting container deployment..."
          START_TIME=$(date +%s)
          
          SSH_PORT="${{ secrets.ssh_port || '22' }}"
          
          # Connect to server and deploy (handled in the remote ssh block below)
          # Run deploy remotely and capture stdout into DEPLOY_OUT
          # Run remote deploy and save stdout to a temp file, then read it
          ssh -p $SSH_PORT ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} 'bash -s' <<'REMOTE_DEPLOY' > /tmp/epilogik_deploy.out
            set -euo pipefail

            # Set deployment variables
            CONTAINER_NAME="${{ inputs.container_name }}"
            IMAGE_NAME="${{ inputs.docker_image }}"
            ENVIRONMENT="${{ inputs.environment }}"
            DEPLOY_STRATEGY="${{ inputs.deploy_strategy }}"

            # Normalize image name robustly:
            # - preserve digest (@sha256:...)
            # - separate tag (:tag) if present
            # - lowercase the registry/repo path
            # - if no registry appears to be present, assume ghcr.io
            ORIG_IMAGE="$IMAGE_NAME"

            # Split out digest if present
            if [[ "$IMAGE_NAME" == *"@"* ]]; then
              NAME_WITH_REGISTRY="${IMAGE_NAME%@*}"
              SUFFIX="@${IMAGE_NAME#*@}"
            else
              NAME_WITH_REGISTRY="$IMAGE_NAME"
              SUFFIX=""
            fi

            # Determine tag (only if the last path segment contains a colon)
            LAST_SEGMENT="${NAME_WITH_REGISTRY##*/}"
            if [[ "$LAST_SEGMENT" == *":"* ]]; then
              TAG=":${LAST_SEGMENT##*:}"
              NAME_BASE="${NAME_WITH_REGISTRY%:*}"
            else
              TAG=""
              NAME_BASE="$NAME_WITH_REGISTRY"
            fi

            # If no registry is present (first component has no '.' and no ':'), assume ghcr.io
            FIRST_COMPONENT="${NAME_BASE%%/*}"
            if [[ "$FIRST_COMPONENT" != *.* && "$FIRST_COMPONENT" != *:* ]]; then
              NAME_BASE="ghcr.io/${NAME_BASE}"
            fi

            # Lowercase only the registry/repo path (keep tag and digest as-is)
            NAME_BASE_LOWER=$(echo "$NAME_BASE" | tr '[:upper:]' '[:lower:]')

            # If there's no explicit tag and no digest, default to :latest to avoid empty references
            if [[ -z "$TAG" && -z "$SUFFIX" ]]; then
              TAG=":latest"
            fi

            NORMALIZED_IMAGE="${NAME_BASE_LOWER}${TAG}${SUFFIX}"

            # Fail-fast if resolved image is empty or still contains uppercase letters in the repo path
            if [ -z "${NORMALIZED_IMAGE}" ]; then
              echo "‚ùå Error: resolved image name is empty (original: '$ORIG_IMAGE')"
              exit 1
            fi

            if [[ "$NORMALIZED_IMAGE" =~ [A-Z] ]]; then
              echo "‚ùå Error: image name still contains uppercase characters after normalization: '$NORMALIZED_IMAGE' (original: '$ORIG_IMAGE')"
              exit 1
            fi

            if [ "$NORMALIZED_IMAGE" != "$ORIG_IMAGE" ]; then
              echo "‚ö†Ô∏è Normalized image name: '$ORIG_IMAGE' -> '$NORMALIZED_IMAGE'"
            fi

            IMAGE_TO_PULL="$NORMALIZED_IMAGE"

            echo "üöÄ Deploying $IMAGE_TO_PULL to $ENVIRONMENT using $DEPLOY_STRATEGY strategy"

            # Create backup of current state for rollback
            if docker ps -a --format "table {{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              PREVIOUS_IMAGE=$(docker inspect --format='{{.Config.Image}}' $CONTAINER_NAME 2>/dev/null || echo "none")
              echo "üíæ Previous image: $PREVIOUS_IMAGE"
            else
              PREVIOUS_IMAGE="none"
            fi

            # Create network if it doesn't exist
            if ! docker network inspect ${{ inputs.docker_network }} >/dev/null 2>&1; then
              echo "üåê Creating Docker network: ${{ inputs.docker_network }}"
              docker network create ${{ inputs.docker_network }}
            fi

            # Login to registry using a temporary docker config directory to avoid writing to runner's default config
            echo "üîê Logging into container registry..."
            TMP_DOCKER_CONFIG=$(mktemp -d)
            export DOCKER_CONFIG="$TMP_DOCKER_CONFIG"
            echo "${{ github.token }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull new image (use normalized image and quote to be safe)
            echo "üì• Pulling image: $IMAGE_TO_PULL"
            if ! docker pull "$IMAGE_TO_PULL"; then
              echo "‚ùå Failed to pull image: $IMAGE_TO_PULL"
              # cleanup docker config before exiting
              rm -rf "$TMP_DOCKER_CONFIG" || true
              exit 1
            fi

            # cleanup temporary docker config
            rm -rf "$TMP_DOCKER_CONFIG" || true

            # Parse environment variables
            ENV_VARS=""
            if [ "${{ inputs.env_vars }}" != "{}" ]; then
              ENV_VARS=$(echo '${{ inputs.env_vars }}' | jq -r 'to_entries[] | "-e \(.key)=\(.value)"' | tr '\n' ' ')
            fi

            # Parse volume mounts
            VOLUME_MOUNTS=""
            if [ "${{ inputs.volumes }}" != "[]" ]; then
              VOLUME_MOUNTS=$(echo '${{ inputs.volumes }}' | jq -r '.[] | "-v \(.)"' | tr '\n' ' ')
            fi

            # Deployment strategy implementation
            case "$DEPLOY_STRATEGY" in
              "rolling")
                echo "üîÑ Executing rolling deployment..."

                # Stop and remove existing container if present
                if docker ps -a --format "table {{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
                  echo "üõë Stopping existing container ${CONTAINER_NAME}..."
                  docker stop ${CONTAINER_NAME} --time=30 || true
                  docker rm ${CONTAINER_NAME} || true
                fi

                # Start new container
                echo "üöÄ Starting new container..."
                CONTAINER_ID=$(docker run -d \
                  --name "${CONTAINER_NAME}" \
                  --network "${{ inputs.docker_network }}" \
                  -p "${{ inputs.host_port }}:${{ inputs.container_port }}" \
                  --restart "${{ inputs.restart_policy }}" \
                  $ENV_VARS \
                  $VOLUME_MOUNTS \
                  "$IMAGE_TO_PULL") || true
                ;;

              "blue-green")
                echo "üîµ Blue-green requested; using rolling fallback for simplicity"
                # For now treat blue-green as rolling which is safe and predictable on target systems
                if docker ps -a --format "table {{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
                  docker stop ${CONTAINER_NAME} --time=30 || true
                  docker rm ${CONTAINER_NAME} || true
                fi
                echo "üöÄ Starting new container (blue-green fallback)..."
                CONTAINER_ID=$(docker run -d \
                  --name "${CONTAINER_NAME}" \
                  --network "${{ inputs.docker_network }}" \
                  -p "${{ inputs.host_port }}:${{ inputs.container_port }}" \
                  --restart "${{ inputs.restart_policy }}" \
                  $ENV_VARS \
                  $VOLUME_MOUNTS \
                  "$IMAGE_TO_PULL") || true
                ;;

              "recreate")
                echo "‚ôªÔ∏è Executing recreate deployment..."

                # Remove existing container if present
                if docker ps -a --format "table {{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
                  echo "üóëÔ∏è Removing existing container..."
                  docker stop ${CONTAINER_NAME} --time=10 || true
                  docker rm ${CONTAINER_NAME} || true
                fi

                # Start new container
                echo "üöÄ Starting new container (recreate)..."
                CONTAINER_ID=$(docker run -d \
                  --name "${CONTAINER_NAME}" \
                  --network "${{ inputs.docker_network }}" \
                  -p "${{ inputs.host_port }}:${{ inputs.container_port }}" \
                  --restart "${{ inputs.restart_policy }}" \
                  $ENV_VARS \
                  $VOLUME_MOUNTS \
                  "$IMAGE_TO_PULL") || true
                ;;

              *)
                echo "‚ùå Unknown deploy strategy '$DEPLOY_STRATEGY'"
                exit 1
                ;;
            esac

            # If docker run produced an ID, trim newline and use it
            CONTAINER_ID=$(echo "${CONTAINER_ID}" | tr -d '\r' || true)

            if [ -z "${CONTAINER_ID}" ]; then
              echo "‚ö†Ô∏è No container ID returned from docker run; deployment may not have started correctly"
              echo "STATUS=failed"
              echo "CONTAINER_ID="
              echo "PREVIOUS_IMAGE=${PREVIOUS_IMAGE:-}"
              # ensure temporary docker config directory cleaned
              rm -rf "$TMP_DOCKER_CONFIG" || true
              exit 1
            fi

            echo "‚úÖ Container started with ID: ${CONTAINER_ID}"

            # Wait for container to be running
            if [ "${{ inputs.wait_for_health }}" = "true" ]; then
              echo "üè• Waiting for container to be running..."
              for i in $(seq 1 12); do
                if docker ps --filter "name=${CONTAINER_NAME}" --filter "status=running" | grep -q ${CONTAINER_NAME}; then
                  echo "‚úÖ Container is running (attempt $i)"
                  break
                fi
                sleep 5
              done
            fi

            # Emit markers for runner parsing
            echo "CONTAINER_ID=${CONTAINER_ID}"
            echo "PREVIOUS_IMAGE=${PREVIOUS_IMAGE:-}"
            echo "STATUS=success"
            echo "üéâ Deployment completed successfully!"
          REMOTE_DEPLOY
          DEPLOY_OUT=$(cat /tmp/epilogik_deploy.out 2>/dev/null || true)
          echo "$DEPLOY_OUT"
          # Parse markers emitted by remote script
          CONTAINER_ID_VAL=$(echo "$DEPLOY_OUT" | grep '^CONTAINER_ID=' | cut -d'=' -f2- | tr -d '\r' || true)
          PREVIOUS_IMAGE_VAL=$(echo "$DEPLOY_OUT" | grep '^PREVIOUS_IMAGE=' | cut -d'=' -f2- | tr -d '\r' || true)
          STATUS_VAL=$(echo "$DEPLOY_OUT" | grep '^STATUS=' | cut -d'=' -f2- | tr -d '\r' || true)

          if [ -n "$CONTAINER_ID_VAL" ]; then
            echo "container_id=$CONTAINER_ID_VAL" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$PREVIOUS_IMAGE_VAL" ]; then
            echo "previous_image=$PREVIOUS_IMAGE_VAL" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$STATUS_VAL" ]; then
            echo "status=$STATUS_VAL" >> "$GITHUB_OUTPUT"
          fi

          # Calculate deployment time
          END_TIME=$(date +%s)
          DEPLOYMENT_TIME=$((END_TIME - START_TIME))
          echo "deployment_time=$DEPLOYMENT_TIME" >> "$GITHUB_OUTPUT"

          echo "‚è±Ô∏è Deployment completed in ${DEPLOYMENT_TIME} seconds"

      - name: üîç Post-deployment verification
        if: steps.deployment.outputs.status == 'success'
        run: |
          echo "üîç Running post-deployment verification..."
          
          SSH_PORT="${{ secrets.ssh_port || '22' }}"
          
          # Run remote post-verify and save stdout to a temp file, then read it
          ssh -p $SSH_PORT ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} 'bash -s' <<'REMOTE_POST' > /tmp/epilogik_postverify.out
            echo "üìä Container status:"
            docker ps --filter "name=${{ inputs.container_name }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            echo ""
            echo "üíæ Container resource usage:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}" ${{ inputs.container_name }}

            echo ""
            echo "üîó Network connectivity:"
            docker exec ${{ inputs.container_name }} ping -c 3 google.com || true
          REMOTE_POST
          POSTVERIFY_OUT=$(cat /tmp/epilogik_postverify.out 2>/dev/null || true)
          echo "$POSTVERIFY_OUT"

      - name: üìä Generate deployment summary
        if: always()
        run: |
          echo "## üöÄ Container Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Deployment Status
          echo "### üìä Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ steps.deployment.outputs.status || 'Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ inputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Strategy | ${{ inputs.deploy_strategy }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Duration | ${{ steps.deployment.outputs.deployment_time || 'N/A' }}s |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ inputs.docker_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Container | \`${{ inputs.container_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Network | \`${{ inputs.docker_network }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Port Mapping | \`${{ inputs.host_port }}:${{ inputs.container_port }}\` |" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ steps.deployment.outputs.container_id }}" ]; then
            echo "| Container ID | \`${{ steps.deployment.outputs.container_id }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -n "${{ steps.deployment.outputs.previous_image }}" ] && [ "${{ steps.deployment.outputs.previous_image }}" != "none" ]; then
            echo "| Previous Image | \`${{ steps.deployment.outputs.previous_image }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Configuration
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚öôÔ∏è Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Feature | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Health Checks | ${{ inputs.wait_for_health && '‚úÖ Enabled' || '‚ùå Disabled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Cleanup | ${{ inputs.cleanup_images && '‚úÖ Enabled' || '‚ùå Disabled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Rollback on Failure | ${{ inputs.rollback_on_failure && '‚úÖ Enabled' || '‚ùå Disabled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Restart Policy | \`${{ inputs.restart_policy }}\` |" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ inputs.health_check_url }}" ]; then
            echo "| Health Check URL | ${{ inputs.health_check_url }} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Results
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.deployment.outputs.status }}" == "success" ]; then
            echo "‚úÖ **Deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "- Monitor application logs and metrics" >> $GITHUB_STEP_SUMMARY
            echo "- Verify all functionality is working as expected" >> $GITHUB_STEP_SUMMARY
            echo "- Run integration tests if available" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.deployment.outputs.status }}" == "rolled-back" ]; then
            echo "üîÑ **Deployment failed but was rolled back successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action Required:**" >> $GITHUB_STEP_SUMMARY
            echo "- Check deployment logs for failure reason" >> $GITHUB_STEP_SUMMARY
            echo "- Fix the issue and retry deployment" >> $GITHUB_STEP_SUMMARY
            echo "- Previous version is currently running" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Troubleshooting Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Check container logs: \`docker logs ${{ inputs.container_name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Verify image exists and is accessible" >> $GITHUB_STEP_SUMMARY
            echo "3. Check port availability and networking" >> $GITHUB_STEP_SUMMARY
            echo "4. Verify environment variables and volumes" >> $GITHUB_STEP_SUMMARY
            echo "5. Check server resources (CPU, memory, disk)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üßπ Cleanup SSH
        if: always()
        run: |
          echo "üßπ Cleaning up SSH configuration..."
          rm -f ~/.ssh/id_rsa
          echo "‚úÖ SSH cleanup completed"