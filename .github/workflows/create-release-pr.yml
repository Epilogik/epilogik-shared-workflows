name: Create Release PR

on:
  workflow_call:
    inputs:
      base_branch:
        description: 'Base branch (e.g., develop)'
        required: false
        type: string
        default: 'develop'
      bump_type:
        description: 'Version bump type (major, minor, patch, or specific version)'
        required: false
        type: string
        default: 'patch'
      tag_prefix:
        description: 'Tag prefix (e.g., "v")'
        required: false
        type: string
        default: 'v'
      auto_merge:
        description: 'Enable auto-merge on PR'
        required: false
        type: boolean
        default: false
    outputs:
      release_version:
        description: 'Calculated release version'
        value: ${{ jobs.create-pr.outputs.version }}
      release_branch:
        description: 'Release branch name'
        value: ${{ jobs.create-pr.outputs.branch }}
      pr_number:
        description: 'Pull request number'
        value: ${{ jobs.create-pr.outputs.pr_number }}

jobs:
  create-pr:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.next_version }}
      branch: ${{ steps.version.outputs.release_branch }}
      pr_number: ${{ steps.create-pr.outputs.pr_number }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.base_branch }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Calculate next version
        id: version
        run: |
          # Get latest tag
          git fetch --tags --prune
          
          # Find latest semantic version tag (format: v1.2.3 or 1.2.3)
          LATEST_TAG=$(git tag -l | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)
          
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="${{ inputs.tag_prefix }}0.0.0"
            echo "⚠️  No semantic version tags found, starting from $LATEST_TAG"
          else
            echo "📌 Latest tag found: $LATEST_TAG"
          fi
          
          # Extract version without prefix (remove 'v' or custom prefix)
          PREFIX="${{ inputs.tag_prefix }}"
          CURRENT_VERSION="${LATEST_TAG#$PREFIX}"
          echo "📊 Current version: $CURRENT_VERSION"
          
          # Parse version parts (handle only semantic versions)
          if [[ ! "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "⚠️  Invalid version format: $CURRENT_VERSION, resetting to 0.0.0"
            CURRENT_VERSION="0.0.0"
          fi
          
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          echo "🔢 Parsed version: $MAJOR.$MINOR.$PATCH"
          
          # Bump version based on bump_type
          case "${{ inputs.bump_type }}" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
            *)
              # If it's a specific version, use it (must be semantic version)
              if [[ "${{ inputs.bump_type }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                MAJOR=$(echo "${{ inputs.bump_type }}" | cut -d. -f1)
                MINOR=$(echo "${{ inputs.bump_type }}" | cut -d. -f2)
                PATCH=$(echo "${{ inputs.bump_type }}" | cut -d. -f3)
                echo "🎯 Using specific version: $MAJOR.$MINOR.$PATCH"
              else
                echo "⚠️  Invalid bump_type, defaulting to patch"
                PATCH=$((PATCH + 1))
              fi
              ;;
          esac
          
          # Final version (semantic versioning only)
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="${{ inputs.tag_prefix }}$NEW_VERSION"
          RELEASE_BRANCH="release/$NEW_VERSION"
          
          echo "next_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "next_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "current_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "release_branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
          
          echo ""
          echo "✅ Version calculation complete:"
          echo "   Current: $LATEST_TAG"
          echo "   Next: $NEW_TAG"
          echo "   Branch: $RELEASE_BRANCH"

      - name: Check existing branch and PR
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_BRANCH="${{ steps.version.outputs.release_branch }}"
          
          # Check if release branch exists
          if git ls-remote --heads origin "$RELEASE_BRANCH" | grep -q "$RELEASE_BRANCH"; then
            echo "branch_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "branch_exists=false" >> "$GITHUB_OUTPUT"
          fi
          
          # Check if PR exists
          PR_COUNT=$(gh pr list --head ${{ inputs.base_branch }} --base "$RELEASE_BRANCH" --state open --json number --jq length)
          if [ "$PR_COUNT" -gt 0 ]; then
            PR_NUMBER=$(gh pr list --head ${{ inputs.base_branch }} --base "$RELEASE_BRANCH" --state open --json number --jq '.[0].number')
            echo "pr_exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          else
            echo "pr_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create or update release branch
        id: branch
        run: |
          RELEASE_BRANCH="${{ steps.version.outputs.release_branch }}"
          BASE_BRANCH="${{ inputs.base_branch }}"
          
          echo "🔍 Checking release branch: $RELEASE_BRANCH"
          
          # Fetch all branches to ensure we have latest info
          git fetch --all --prune
          
          if [ "${{ steps.check.outputs.branch_exists }}" == "false" ]; then
            echo "🆕 Creating new release branch: $RELEASE_BRANCH"
            git checkout -b "$RELEASE_BRANCH"
            
            # Create a version bump commit to ensure there's a difference
            mkdir -p .github
            echo "${{ steps.version.outputs.next_version }}" > .github/VERSION
            git add .github/VERSION
            git commit -m "chore: bump version to ${{ steps.version.outputs.next_version }}"
            
            git push origin "$RELEASE_BRANCH"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "diff_count=0" >> $GITHUB_OUTPUT
          else
            # Check for differences
            git fetch origin "$RELEASE_BRANCH"
            git fetch origin ${{ inputs.base_branch }}
            DIFF_COUNT=$(git rev-list --count origin/$RELEASE_BRANCH..origin/${{ inputs.base_branch }})

            echo "has_changes=$([ "$DIFF_COUNT" -gt 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
            echo "diff_count=$DIFF_COUNT" >> $GITHUB_OUTPUT
            
            if [ "$DIFF_COUNT" -gt 0 ]; then
              echo "📝 Found $DIFF_COUNT new commits in ${{ inputs.base_branch }}"
            else
              echo "ℹ️  No new commits - branches are in sync"
            fi
          fi
          
          echo "✅ Release branch ready: $RELEASE_BRANCH"

      - name: Generate release notes
        if: steps.branch.outputs.has_changes == 'true'
        id: notes
        run: |
          echo "release_notes=Release notes will be generated automatically" >> $GITHUB_OUTPUT
          echo "commit_count=1" >> $GITHUB_OUTPUT

      - name: Create or update PR
        id: create-pr
        if: steps.branch.outputs.has_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE_BRANCH="${{ steps.version.outputs.release_branch }}"
          VERSION="${{ steps.version.outputs.next_version }}"
          
          PR_BODY="## 🚀 Release v$VERSION

          ### 📋 Version Information
          - **Previous:** ${{ steps.version.outputs.current_tag }}
          - **New:** ${{ steps.version.outputs.next_tag }}
          - **Branch:** \`${{ inputs.base_branch }}\` → \`$RELEASE_BRANCH\`

          ### 📝 Changes
          ${{ steps.notes.outputs.release_notes }}

          ### ✅ Checklist
          - [ ] Code reviewed
          - [ ] Tests passing
          - [ ] Documentation updated

          ### 🎯 Next Steps
          1. Review the changes
          2. Merge this PR to update release branch
          3. Production deployment will start automatically

          ---
          **Auto-generated** • $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          if [ "${{ steps.check.outputs.pr_exists }}" == "false" ]; then
            echo "🆕 Creating new PR..."
            PR_URL=$(gh pr create \
              --title "🚀 Release v$VERSION" \
              --body "$PR_BODY" \
              --base "$RELEASE_BRANCH" \
              --head ${{ inputs.base_branch }})
            
            PR_NUMBER=$(echo "$PR_URL" | grep -oP '\d+$')
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            
            ${{ inputs.auto_merge && 'gh pr merge $PR_NUMBER --auto --squash' || 'echo "Auto-merge disabled"' }}
          else
            echo "🔄 Updating existing PR..."
            gh pr comment "${{ steps.check.outputs.pr_number }}" --body "🔄 **Updated** • $(date -u +'%Y-%m-%d %H:%M:%S UTC')\n\n${{ steps.notes.outputs.release_notes }}"
            echo "pr_number=${{ steps.check.outputs.pr_number }}" >> $GITHUB_OUTPUT
          fi

      - name: Summary
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📦 Release v${{ steps.version.outputs.next_version }}"
          echo "🌿 Branch: ${{ steps.version.outputs.release_branch }}"
          echo "📝 Commits: ${{ steps.notes.outputs.commit_count }}"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
